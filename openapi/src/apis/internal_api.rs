/*
 * Sindri Labs API
 *
 *  ## About [Sindri Labs](https://www.sindri.app/)' API simplifies the developer experience to enable fast and scalable zero-knowledge proof generation.  Front-End Dashboard: [https://sindri.app/login](https://sindri.app/login)  ## Documentation The [Sindri Documentation](https://sindri.app/docs) contains everything you need to get started!  ## Sindri Resources The [sindri-resources GitHub repo](https://github.com/Sindri-Labs/sindri-resources) contains contains resources and sample data for the Sindri API.  ## Using this Page This is a standard [OpenAPI (Swagger)](https://swagger.io/specification/) API documentation page. It provides detailed documentation for each endpoint.  This page enables easy prototyping via the \"Try it out\" feature!  Since all Sindri endpoints require a valid API Key, in order to use the \"Try it out\" feature for any endpoint in this documentation you must first obtain an API key. Do this in one of two ways: 1. Enter your username and password in the `/api/apikey/generate` endpoint of the **Authorization** section below. Use the API key returned in the `access` field of the response. 2. Obtain an API key from the Sindri Dashboard team \"Account Settings\".  After obtaining your API key, authorize your page session by entering your API Key in the `SindriAPIKeyBearerAuth` section, reached by clicking \"Authorize\" below.  Proving Backend Version: v1.2.4
 *
 * The version of the OpenAPI document: v1.17.8
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{Deserialize, Serialize};

/// struct for typed errors of method [`circuit_download`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CircuitDownloadError {
    Status404(),
    Status500(models::SindriInternalErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`circuit_proofs_paginated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CircuitProofsPaginatedError {
    Status404(models::CircuitDoesNotExistResponse),
    Status500(models::SindriInternalErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`circuit_smart_contract_verifier`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CircuitSmartContractVerifierError {
    Status404(models::CircuitDoesNotExistResponse),
    Status409(models::CircuitIsNotReadyResponse),
    Status500(models::SindriInternalErrorResponse),
    Status501(models::ComingSoonResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`circuit_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CircuitStatusError {
    Status404(models::CircuitDoesNotExistResponse),
    Status500(models::SindriInternalErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`password_change_with_jwt_auth`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PasswordChangeWithJwtAuthError {
    Status422(models::ValidationErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_circuits`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectCircuitsError {
    Status404(models::ProjectDoesNotExistResponse),
    Status500(models::SindriInternalErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_circuits_paginated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectCircuitsPaginatedError {
    Status404(models::ProjectDoesNotExistResponse),
    Status500(models::SindriInternalErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectDeleteError {
    Status404(models::ProjectDoesNotExistResponse),
    Status500(models::SindriInternalErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_detail`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectDetailError {
    Status404(models::ProjectDoesNotExistResponse),
    Status500(models::SindriInternalErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectListError {
    Status500(models::SindriInternalErrorResponse),
    Status404(models::TeamDoesNotExistResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_list_paginated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectListPaginatedError {
    Status500(models::SindriInternalErrorResponse),
    Status404(models::TeamDoesNotExistResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_proofs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectProofsError {
    Status404(models::ProjectDoesNotExistResponse),
    Status500(models::SindriInternalErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_proofs_paginated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectProofsPaginatedError {
    Status404(models::ProjectDoesNotExistResponse),
    Status500(models::SindriInternalErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_settings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectSettingsError {
    Status404(models::ProjectDoesNotExistResponse),
    Status500(models::SindriInternalErrorResponse),
    Status422(models::ValidationErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`proof_histogram`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProofHistogramError {
    Status500(models::SindriInternalErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`proof_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProofListError {
    Status500(models::SindriInternalErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`proof_list_paginated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProofListPaginatedError {
    Status500(models::SindriInternalErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`proof_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProofStatusError {
    Status404(models::ProofDoesNotExistResponse),
    Status500(models::SindriInternalErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sindri_manifest_schema`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SindriManifestSchemaError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_avatar_upload`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamAvatarUploadError {
    Status400(models::SindriInvalidUploadResponse),
    Status500(models::SindriInternalErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamCreateError {
    Status400(models::SindriValueErrorResponse),
    Status409(models::TeamAlreadyExistsResponse),
    Status500(models::SindriInternalErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_detail`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDetailError {
    Status404(models::TeamDoesNotExistResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamInviteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_me`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamMeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_members`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamMembersError {
    Status404(models::TeamDoesNotExistResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_remove_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamRemoveMemberError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_me_with_jwt_auth`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserMeWithJwtAuthError {
    UnknownValue(serde_json::Value),
}

/// Obtain circuit file(s).
pub async fn circuit_download(
    configuration: &configuration::Configuration,
    circuit_id: &str,
    path: Option<&str>,
) -> Result<reqwest::Response, Error<CircuitDownloadError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_circuit_id = circuit_id;
    let p_path = path;

    let uri_str = format!(
        "{}/api/v1/circuit/{circuit_id}/download",
        configuration.base_path,
        circuit_id = crate::apis::urlencode(p_circuit_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_path {
        req_builder = req_builder.query(&[("path", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(resp)
    } else {
        let content = resp.text().await?;
        let entity: Option<CircuitDownloadError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// List all proofs for a circuit.
pub async fn circuit_proofs_paginated(
    configuration: &configuration::Configuration,
    circuit_id: &str,
    limit: Option<i32>,
    offset: Option<i32>,
) -> Result<models::PagedProofInfoResponse, Error<CircuitProofsPaginatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_circuit_id = circuit_id;
    let p_limit = limit;
    let p_offset = offset;

    let uri_str = format!(
        "{}/api/v1/circuit/{circuit_id}/proofs/paginated",
        configuration.base_path,
        circuit_id = crate::apis::urlencode(p_circuit_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CircuitProofsPaginatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get smart contract verifier for existing circuit
pub async fn circuit_smart_contract_verifier(
    configuration: &configuration::Configuration,
    circuit_id: &str,
) -> Result<models::SmartContractVerifierResponse, Error<CircuitSmartContractVerifierError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_circuit_id = circuit_id;

    let uri_str = format!(
        "{}/api/v1/circuit/{circuit_id}/smart_contract_verifier",
        configuration.base_path,
        circuit_id = crate::apis::urlencode(p_circuit_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CircuitSmartContractVerifierError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get status for a specific circuit.
pub async fn circuit_status(
    configuration: &configuration::Configuration,
    circuit_id: &str,
) -> Result<models::CircuitStatusResponse, Error<CircuitStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_circuit_id = circuit_id;

    let uri_str = format!(
        "{}/api/v1/circuit/{circuit_id}/status",
        configuration.base_path,
        circuit_id = crate::apis::urlencode(p_circuit_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CircuitStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Change user password. Requires JWT authentication.
pub async fn password_change_with_jwt_auth(
    configuration: &configuration::Configuration,
    password_change_input: models::PasswordChangeInput,
) -> Result<models::ActionResponse, Error<PasswordChangeWithJwtAuthError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_password_change_input = password_change_input;

    let uri_str = format!("{}/api/v1/password/change", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_password_change_input);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PasswordChangeWithJwtAuthError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// List all circuits for a project.
pub async fn project_circuits(
    configuration: &configuration::Configuration,
    project_id: &str,
) -> Result<Vec<models::CircuitInfoResponse>, Error<ProjectCircuitsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project_id = project_id;

    let uri_str = format!(
        "{}/api/v1/project/{project_id}/circuits",
        configuration.base_path,
        project_id = crate::apis::urlencode(p_project_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectCircuitsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// List all circuits for a project.
pub async fn project_circuits_paginated(
    configuration: &configuration::Configuration,
    project_id: &str,
    limit: Option<i32>,
    offset: Option<i32>,
) -> Result<models::PagedCircuitInfoResponse, Error<ProjectCircuitsPaginatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project_id = project_id;
    let p_limit = limit;
    let p_offset = offset;

    let uri_str = format!(
        "{}/api/v1/project/{project_id}/circuits/paginated",
        configuration.base_path,
        project_id = crate::apis::urlencode(p_project_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectCircuitsPaginatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Delete a project.
pub async fn project_delete(
    configuration: &configuration::Configuration,
    project_id: &str,
) -> Result<models::ActionResponse, Error<ProjectDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project_id = project_id;

    let uri_str = format!(
        "{}/api/v1/project/{project_id}/delete",
        configuration.base_path,
        project_id = crate::apis::urlencode(p_project_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get info for a project.
pub async fn project_detail(
    configuration: &configuration::Configuration,
    project_id: &str,
) -> Result<models::ProjectInfoResponse, Error<ProjectDetailError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project_id = project_id;

    let uri_str = format!(
        "{}/api/v1/project/{project_id}/detail",
        configuration.base_path,
        project_id = crate::apis::urlencode(p_project_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectDetailError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// List all projects meeting filter criteria.
pub async fn project_list(
    configuration: &configuration::Configuration,
    project_list_input: models::ProjectListInput,
) -> Result<Vec<models::ProjectInfoResponse>, Error<ProjectListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project_list_input = project_list_input;

    let uri_str = format!("{}/api/v1/project/list", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_project_list_input);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// List all projects meeting filter criteria.
pub async fn project_list_paginated(
    configuration: &configuration::Configuration,
    project_list_input: models::ProjectListInput,
    limit: Option<i32>,
    offset: Option<i32>,
) -> Result<models::PagedProjectInfoResponse, Error<ProjectListPaginatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project_list_input = project_list_input;
    let p_limit = limit;
    let p_offset = offset;

    let uri_str = format!("{}/api/v1/project/list/paginated", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_project_list_input);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectListPaginatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get all proofs for a project.
pub async fn project_proofs(
    configuration: &configuration::Configuration,
    project_id: &str,
) -> Result<Vec<models::ProofInfoResponse>, Error<ProjectProofsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project_id = project_id;

    let uri_str = format!(
        "{}/api/v1/project/{project_id}/proofs",
        configuration.base_path,
        project_id = crate::apis::urlencode(p_project_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectProofsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get all proofs for a project.
pub async fn project_proofs_paginated(
    configuration: &configuration::Configuration,
    project_id: &str,
    limit: Option<i32>,
    offset: Option<i32>,
) -> Result<models::PagedProofInfoResponse, Error<ProjectProofsPaginatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project_id = project_id;
    let p_limit = limit;
    let p_offset = offset;

    let uri_str = format!(
        "{}/api/v1/project/{project_id}/proofs/paginated",
        configuration.base_path,
        project_id = crate::apis::urlencode(p_project_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectProofsPaginatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Update project settings.
pub async fn project_settings(
    configuration: &configuration::Configuration,
    project_name: &str,
    project_settings_input: models::ProjectSettingsInput,
) -> Result<models::ProjectInfoResponse, Error<ProjectSettingsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project_name = project_name;
    let p_project_settings_input = project_settings_input;

    let uri_str = format!(
        "{}/api/v1/project/{project_name}/settings",
        configuration.base_path,
        project_name = crate::apis::urlencode(p_project_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_project_settings_input);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectSettingsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get histogram data for a team's proofs.
pub async fn proof_histogram(
    configuration: &configuration::Configuration,
    proof_histogram_input: models::ProofHistogramInput,
) -> Result<models::ProofHistogramResponse, Error<ProofHistogramError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_proof_histogram_input = proof_histogram_input;

    let uri_str = format!("{}/api/v1/proof/histogram", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_proof_histogram_input);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProofHistogramError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// List proofs for the requesting team.
pub async fn proof_list(
    configuration: &configuration::Configuration,
    proof_list_input: models::ProofListInput,
) -> Result<Vec<models::ProofInfoResponse>, Error<ProofListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_proof_list_input = proof_list_input;

    let uri_str = format!("{}/api/v1/proof/list", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_proof_list_input);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProofListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// List proofs for the requesting team.
pub async fn proof_list_paginated(
    configuration: &configuration::Configuration,
    proof_list_input: models::ProofListInput,
    limit: Option<i32>,
    offset: Option<i32>,
) -> Result<models::PagedProofInfoResponse, Error<ProofListPaginatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_proof_list_input = proof_list_input;
    let p_limit = limit;
    let p_offset = offset;

    let uri_str = format!("{}/api/v1/proof/list/paginated", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_proof_list_input);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProofListPaginatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get status for a specific proof.
pub async fn proof_status(
    configuration: &configuration::Configuration,
    proof_id: &str,
) -> Result<models::ProofStatusResponse, Error<ProofStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_proof_id = proof_id;

    let uri_str = format!(
        "{}/api/v1/proof/{proof_id}/status",
        configuration.base_path,
        proof_id = crate::apis::urlencode(p_proof_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProofStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Return Sindri manifest schema as JSON.
pub async fn sindri_manifest_schema(
    configuration: &configuration::Configuration,
) -> Result<serde_json::Value, Error<SindriManifestSchemaError>> {
    let uri_str = format!(
        "{}/api/v1/sindri-manifest-schema.json",
        configuration.base_path
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SindriManifestSchemaError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Upload avatar for the team
pub async fn team_avatar_upload(
    configuration: &configuration::Configuration,
    files: Vec<std::path::PathBuf>,
) -> Result<models::TeamMeResponse, Error<TeamAvatarUploadError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let _p_files = files;

    let uri_str = format!("{}/api/v1/team/avatar/upload", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    let multipart_form = reqwest::multipart::Form::new();
    // TODO: support file upload for 'files' parameter
    req_builder = req_builder.multipart(multipart_form);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TeamAvatarUploadError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Create a new team
pub async fn team_create(
    configuration: &configuration::Configuration,
    team_create_input: models::TeamCreateInput,
    sindri_team_id: Option<&str>,
) -> Result<models::TeamDetail, Error<TeamCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_team_create_input = team_create_input;
    let p_sindri_team_id = sindri_team_id;

    let uri_str = format!("{}/api/v1/team/create", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_sindri_team_id {
        req_builder = req_builder.header("Sindri-Team-Id", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_team_create_input);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TeamCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Return details for the specified team
pub async fn team_detail(
    configuration: &configuration::Configuration,
    team_slug: &str,
) -> Result<models::TeamDetail, Error<TeamDetailError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_team_slug = team_slug;

    let uri_str = format!(
        "{}/api/v1/team/{team_slug}/detail",
        configuration.base_path,
        team_slug = crate::apis::urlencode(p_team_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TeamDetailError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Invite an email address to join the specified team
pub async fn team_invite(
    configuration: &configuration::Configuration,
    team_invite_input: models::TeamInviteInput,
    sindri_team_id: Option<&str>,
) -> Result<models::ActionResponse, Error<TeamInviteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_team_invite_input = team_invite_input;
    let p_sindri_team_id = sindri_team_id;

    let uri_str = format!("{}/api/v1/team/invite", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_sindri_team_id {
        req_builder = req_builder.header("Sindri-Team-Id", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_team_invite_input);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TeamInviteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Obtain team details for the currently authenticated team
pub async fn team_me(
    configuration: &configuration::Configuration,
) -> Result<models::TeamMeResponse, Error<TeamMeError>> {
    let uri_str = format!("{}/api/v1/team/me", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TeamMeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Return member list for the specified team
pub async fn team_members(
    configuration: &configuration::Configuration,
    team_slug: &str,
    sindri_team_id: Option<&str>,
) -> Result<models::TeamMembersResponse, Error<TeamMembersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_team_slug = team_slug;
    let p_sindri_team_id = sindri_team_id;

    let uri_str = format!(
        "{}/api/v1/team/{team_slug}/members",
        configuration.base_path,
        team_slug = crate::apis::urlencode(p_team_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_sindri_team_id {
        req_builder = req_builder.header("Sindri-Team-Id", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TeamMembersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Remove a user from the specified team. Revokes all team API keys if the removed user was the last team member.
pub async fn team_remove_member(
    configuration: &configuration::Configuration,
    team_remove_member_input: models::TeamRemoveMemberInput,
    sindri_team_id: Option<&str>,
) -> Result<models::ActionResponse, Error<TeamRemoveMemberError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_team_remove_member_input = team_remove_member_input;
    let p_sindri_team_id = sindri_team_id;

    let uri_str = format!("{}/api/v1/team/remove-member", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_sindri_team_id {
        req_builder = req_builder.header("Sindri-Team-Id", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_team_remove_member_input);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<TeamRemoveMemberError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Obtain user details. Requires JWT authentication.
pub async fn user_me_with_jwt_auth(
    configuration: &configuration::Configuration,
) -> Result<models::UserMeResponse, Error<UserMeWithJwtAuthError>> {
    let uri_str = format!("{}/api/v1/user/me", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<UserMeWithJwtAuthError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
