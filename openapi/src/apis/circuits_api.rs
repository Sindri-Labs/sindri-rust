/*
 * Sindri Labs API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.15.1
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`circuit_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CircuitCreateError {
    Status400(models::ForgeInvalidUploadResponse),
    Status422(models::ValidationErrorResponse),
    Status500(models::ForgeInternalErrorResponse),
    Status501(models::ComingSoonResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`circuit_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CircuitDeleteError {
    Status404(models::CircuitDoesNotExistResponse),
    Status500(models::ForgeInternalErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`circuit_detail`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CircuitDetailError {
    Status404(models::CircuitDoesNotExistResponse),
    Status500(models::ForgeInternalErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`circuit_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CircuitListError {
    Status500(models::ForgeInternalErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`circuit_proofs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CircuitProofsError {
    Status404(models::CircuitDoesNotExistResponse),
    Status500(models::ForgeInternalErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`proof_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProofCreateError {
    Status400(models::ProofCannotBeCreatedResponse),
    Status404(models::CircuitDoesNotExistResponse),
    Status409(models::CircuitIsNotReadyResponse),
    Status501(models::ComingSoonResponse),
    UnknownValue(serde_json::Value),
}


/// Create a circuit.
pub async fn circuit_create(configuration: &configuration::Configuration, files: Vec<u8>, meta: Option<std::collections::HashMap<String, String>>, tags: Option<Vec<String>>) -> Result<models::CircuitInfoResponse, Error<CircuitCreateError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/circuit/create", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    // Build the request body directly in order to avoid a streaming request
    // that is incompatible with the retry middleware
    let boundary = "----------------------------4ebf00fbcf09";
    local_var_req_builder = local_var_req_builder.header(
        "Content-Type",
        format!("multipart/form-data; boundary={boundary}"),
    );

    let filename = "rust_sdk_upload.tar.gz";
    let mut byte_string = Vec::new();
    byte_string.extend_from_slice(
        format!(
            "--{boundary}\r\n\
            Content-Disposition: form-data; name=\"files\"; filename=\"{filename}\"\r\n\
            \r\n",
        )
        .as_bytes(),
    );
    byte_string.extend(files);
    byte_string.extend_from_slice(format!("--{boundary}--\r\n").as_bytes()); // End of files
    if let Some(tags) = tags {
        for tag in tags {
            byte_string.extend_from_slice(
                format!(
                    "--{boundary}\r\n\
                    Content-Disposition: form-data; name=\"tags\"\r\n\
                    \r\n\
                    {tag}\r\n"
                )
                .as_bytes(),
            );
            byte_string.extend_from_slice(format!("--{boundary}--\r\n").as_bytes()); // End of tag
        }
    }
    if let Some(meta) = meta {
        let meta_json = serde_json::to_string(&meta)?;
        byte_string.extend_from_slice(format!("--{boundary}\r\n\
           Content-Disposition: form-data; name=\"meta\"\r\n\
           Content-Type: application/json\r\n\
            \r\n\
            {meta_json}\r\n").as_bytes());
        byte_string.extend_from_slice(format!("--{boundary}--\r\n").as_bytes()); // End of meta
    }
    let local_var_body = reqwest::Body::from(byte_string);

    local_var_req_builder = local_var_req_builder.body(local_var_body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CircuitCreateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a circuit.
pub async fn circuit_delete(configuration: &configuration::Configuration, circuit_id: &str) -> Result<models::ActionResponse, Error<CircuitDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/circuit/{circuit_id}/delete", local_var_configuration.base_path, circuit_id=crate::apis::urlencode(circuit_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CircuitDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get info for an existing circuit.
pub async fn circuit_detail(configuration: &configuration::Configuration, circuit_id: &str, include_verification_key: Option<bool>) -> Result<models::CircuitInfoResponse, Error<CircuitDetailError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/circuit/{circuit_id}/detail", local_var_configuration.base_path, circuit_id=crate::apis::urlencode(circuit_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = include_verification_key {
        local_var_req_builder = local_var_req_builder.query(&[("include_verification_key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CircuitDetailError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List all circuits owned by team.
pub async fn circuit_list(configuration: &configuration::Configuration, ) -> Result<Vec<models::CircuitInfoResponse>, Error<CircuitListError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/circuit/list", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CircuitListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List all proofs for a circuit.
pub async fn circuit_proofs(configuration: &configuration::Configuration, circuit_id: &str) -> Result<Vec<models::ProofInfoResponse>, Error<CircuitProofsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/circuit/{circuit_id}/proofs", local_var_configuration.base_path, circuit_id=crate::apis::urlencode(circuit_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CircuitProofsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Prove a circuit with specific inputs.
pub async fn proof_create(configuration: &configuration::Configuration, circuit_id: &str, circuit_prove_input: models::CircuitProveInput) -> Result<models::ProofInfoResponse, Error<ProofCreateError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/circuit/{circuit_id}/prove", local_var_configuration.base_path, circuit_id=crate::apis::urlencode(circuit_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&circuit_prove_input);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProofCreateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

