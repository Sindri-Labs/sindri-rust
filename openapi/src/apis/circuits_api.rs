/*
 * Sindri Labs API
 *
 *  ## About [Sindri Labs](https://www.sindri.app/)' API simplifies the developer experience to enable fast and scalable zero-knowledge proof generation. Front-End Dashboard: [https://sindri.app/login](https://sindri.app/login) ## Documentation The [Sindri Documentation](https://sindri.app/docs) contains everything you need to get started! ## Sindri Resources The [sindri-resources GitHub repo](https://github.com/Sindri-Labs/sindri-resources) contains contains resources and sample data for the Sindri API. ## Using this Page This is a standard [OpenAPI (Swagger)](https://swagger.io/specification/) API documentation page. It provides detailed documentation for each endpoint. This page enables easy prototyping via the \"Try it out\" feature! Since all Sindri endpoints require a valid API Key, in order to use the \"Try it out\" feature for any endpoint in this documentation you must first obtain an API key. Do this in one of two ways: 1. Enter your username and password in the `/api/apikey/generate` endpoint of the **Authorization** section below. Use the API key returned in the `access` field of the response. 2. Obtain an API key from the Sindri Dashboard team \"Account Settings\". After obtaining your API key, authorize your page session by entering your API Key in the `SindriAPIKeyBearerAuth` section, reached by clicking \"Authorize\" below. Proving Backend Version: v1.2.17
 *
 * The version of the OpenAPI document: v1.17.28
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{Deserialize, Serialize};

/// struct for typed errors of method [`circuit_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CircuitCreateError {
    Status422(models::ValidationErrorResponse),
    Status501(models::ComingSoonResponse),
    Status500(models::SindriInternalErrorResponse),
    Status400(models::SindriInvalidUploadResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`circuit_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CircuitDeleteError {
    Status404(models::CircuitDoesNotExistResponse),
    Status500(models::SindriInternalErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`circuit_detail`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CircuitDetailError {
    Status404(models::CircuitDoesNotExistResponse),
    Status500(models::SindriInternalErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`circuit_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CircuitListError {
    Status500(models::SindriInternalErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`circuit_proofs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CircuitProofsError {
    Status404(models::CircuitDoesNotExistResponse),
    Status500(models::SindriInternalErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`proof_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProofCreateError {
    Status404(models::CircuitDoesNotExistResponse),
    Status409(models::CircuitIsNotReadyResponse),
    Status400(models::ProofCannotBeCreatedResponse),
    Status501(models::ComingSoonResponse),
    UnknownValue(serde_json::Value),
}

/// Create a circuit.
pub async fn circuit_create(
    configuration: &configuration::Configuration,
    files: Vec<u8>,
    meta: Option<std::collections::HashMap<String, String>>,
    tags: Option<Vec<String>>,
) -> Result<models::CircuitInfoResponse, Error<CircuitCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_files = files;
    let p_meta = meta;
    let p_tags = tags;

    let uri_str = format!("{}/api/v1/circuit/create", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    // Build the request body directly in order to avoid a streaming request
    // that is incompatible with the retry middleware
    let boundary = "----------------------------4ebf00fbcf09";
    req_builder = req_builder.header(
        "Content-Type",
        format!("multipart/form-data; boundary={boundary}"),
    );

    let filename = "rust_sdk_upload.tar.gz";
    let mut byte_string = Vec::new();
    byte_string.extend_from_slice(
        format!(
            "--{boundary}\r\n\
            Content-Disposition: form-data; name=\"files\"; filename=\"{filename}\"\r\n\
            \r\n",
        )
        .as_bytes(),
    );
    byte_string.extend(p_files);
    byte_string.extend_from_slice(format!("--{boundary}--\r\n").as_bytes()); // End of files
    if let Some(p_tags) = p_tags {
        for tag in p_tags {
            byte_string.extend_from_slice(
                format!(
                    "--{boundary}\r\n\
                    Content-Disposition: form-data; name=\"tags\"\r\n\
                    \r\n\
                    {tag}\r\n"
                )
                .as_bytes(),
            );
            byte_string.extend_from_slice(format!("--{boundary}--\r\n").as_bytes());
            // End of tag
        }
    }
    if let Some(p_meta) = p_meta {
        let meta_json = serde_json::to_string(&p_meta)?;
        byte_string.extend_from_slice(
            format!(
                "--{boundary}\r\n\
           Content-Disposition: form-data; name=\"meta\"\r\n\
           Content-Type: application/json\r\n\
            \r\n\
            {meta_json}\r\n"
            )
            .as_bytes(),
        );
        byte_string.extend_from_slice(format!("--{boundary}--\r\n").as_bytes());
        // End of meta
    }
    let local_var_body = reqwest::Body::from(byte_string);
    req_builder = req_builder.body(local_var_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CircuitCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Delete a circuit.
pub async fn circuit_delete(
    configuration: &configuration::Configuration,
    circuit_id: Option<&str>,
) -> Result<models::ActionResponse, Error<CircuitDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_circuit_id = circuit_id;

    let uri_str = format!(
        "{}/api/v1/circuit/{circuit_id}/delete",
        configuration.base_path,
        circuit_id = crate::apis::urlencode(p_circuit_id.unwrap())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CircuitDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get info for an existing circuit.
pub async fn circuit_detail(
    configuration: &configuration::Configuration,
    circuit_id: &str,
    include_verification_key: Option<bool>,
) -> Result<models::CircuitInfoResponse, Error<CircuitDetailError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_circuit_id = circuit_id;
    let p_include_verification_key = include_verification_key;

    let uri_str = format!(
        "{}/api/v1/circuit/{circuit_id}/detail",
        configuration.base_path,
        circuit_id = crate::apis::urlencode(p_circuit_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_include_verification_key {
        req_builder = req_builder.query(&[("include_verification_key", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CircuitDetailError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// List all circuits owned by team.
pub async fn circuit_list(
    configuration: &configuration::Configuration,
) -> Result<Vec<models::CircuitInfoResponse>, Error<CircuitListError>> {
    let uri_str = format!("{}/api/v1/circuit/list", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CircuitListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// List all proofs for a circuit.
pub async fn circuit_proofs(
    configuration: &configuration::Configuration,
    circuit_id: &str,
) -> Result<Vec<models::ProofInfoResponse>, Error<CircuitProofsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_circuit_id = circuit_id;

    let uri_str = format!(
        "{}/api/v1/circuit/{circuit_id}/proofs",
        configuration.base_path,
        circuit_id = crate::apis::urlencode(p_circuit_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CircuitProofsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Prove a circuit with specific inputs.
pub async fn proof_create(
    configuration: &configuration::Configuration,
    circuit_id: &str,
    circuit_prove_input: models::CircuitProveInput,
) -> Result<models::ProofInfoResponse, Error<ProofCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_circuit_id = circuit_id;
    let p_circuit_prove_input = circuit_prove_input;

    let uri_str = format!(
        "{}/api/v1/circuit/{circuit_id}/prove",
        configuration.base_path,
        circuit_id = crate::apis::urlencode(p_circuit_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_circuit_prove_input);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ProofCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
