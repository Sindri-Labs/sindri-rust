/*
 * Sindri Labs API
 *
 *  ## About [Sindri Labs](https://www.sindri.app/)' API simplifies the developer experience to enable fast and scalable zero-knowledge proof generation.  Front-End Dashboard: [https://sindri.app/login](https://sindri.app/login)  ## Documentation The [Sindri Documentation](https://sindri.app/docs) contains everything you need to get started!  ## Sindri Resources The [sindri-resources GitHub repo](https://github.com/Sindri-Labs/sindri-resources) contains contains resources and sample data for the Sindri API.  ## Using this Page This is a standard [OpenAPI (Swagger)](https://swagger.io/specification/) API documentation page. It provides detailed documentation for each endpoint.  This page enables easy prototyping via the \"Try it out\" feature!  Since all Sindri endpoints require a valid API Key, in order to use the \"Try it out\" feature for any endpoint in this documentation you must first obtain an API key. Do this in one of two ways: 1. Enter your username and password in the `/api/apikey/generate` endpoint of the **Authorization** section below. Use the API key returned in the `access` field of the response. 2. Obtain an API key from the Sindri Dashboard team \"Account Settings\".  After obtaining your API key, authorize your page session by entering your API Key in the `SindriAPIKeyBearerAuth` section, reached by clicking \"Authorize\" below.  Proving Backend Version: v1.0.36 
 *
 * The version of the OpenAPI document: v1.14.5
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method [`proof_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProofDeleteError {
    Status404(crate::models::ProofDoesNotExistResponse),
    Status500(crate::models::ForgeInternalErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`proof_detail`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProofDetailError {
    Status404(crate::models::ProofDoesNotExistResponse),
    Status500(crate::models::ForgeInternalErrorResponse),
    Status501(crate::models::ComingSoonResponse),
    UnknownValue(serde_json::Value),
}


/// Delete a specific proof.
pub async fn proof_delete(configuration: &configuration::Configuration, proof_id: serde_json::Value) -> Result<crate::models::ActionResponse, Error<ProofDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/proof/{proof_id}/delete", local_var_configuration.base_path, proof_id=proof_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProofDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get info for a specific proof.
pub async fn proof_detail(configuration: &configuration::Configuration, proof_id: serde_json::Value, include_proof: Option<serde_json::Value>, include_public: Option<serde_json::Value>, include_smart_contract_calldata: Option<serde_json::Value>, include_verification_key: Option<serde_json::Value>) -> Result<crate::models::ProofInfoResponse, Error<ProofDetailError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/proof/{proof_id}/detail", local_var_configuration.base_path, proof_id=proof_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = include_proof {
        local_var_req_builder = local_var_req_builder.query(&[("include_proof", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_public {
        local_var_req_builder = local_var_req_builder.query(&[("include_public", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_smart_contract_calldata {
        local_var_req_builder = local_var_req_builder.query(&[("include_smart_contract_calldata", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_verification_key {
        local_var_req_builder = local_var_req_builder.query(&[("include_verification_key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProofDetailError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

